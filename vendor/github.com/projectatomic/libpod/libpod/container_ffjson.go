// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: /home/mcs/code/gopath//src/github.com/projectatomic/libpod/libpod/container.go

package libpod

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/containernetworking/cni/pkg/types/current"
	"github.com/cri-o/ocicni/pkg/ocicni"
	"github.com/opencontainers/runtime-spec/specs-go"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"net"
	"reflect"
)

// MarshalJSON marshal bytes to json - template
func (j *ContainerConfig) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ContainerConfig) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Spec != nil {
		/* Struct fall back. type=specs.Spec kind=struct */
		buf.WriteString(`{"spec":`)
		err = buf.Encode(j.Spec)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`{"spec":null`)
	}
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteByte(',')
	if len(j.Pod) != 0 {
		buf.WriteString(`"pod":`)
		fflib.WriteJsonString(buf, string(j.Pod))
		buf.WriteByte(',')
	}
	if len(j.Namespace) != 0 {
		buf.WriteString(`"namespace":`)
		fflib.WriteJsonString(buf, string(j.Namespace))
		buf.WriteByte(',')
	}
	if true {
		/* Struct fall back. type=storage.IDMappingOptions kind=struct */
		buf.WriteString(`"idMappingsOptions":`)
		err = buf.Encode(&j.IDMappings)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.RootfsImageID) != 0 {
		buf.WriteString(`"rootfsImageID":`)
		fflib.WriteJsonString(buf, string(j.RootfsImageID))
		buf.WriteByte(',')
	}
	if len(j.RootfsImageName) != 0 {
		buf.WriteString(`"rootfsImageName":`)
		fflib.WriteJsonString(buf, string(j.RootfsImageName))
		buf.WriteByte(',')
	}
	if len(j.Rootfs) != 0 {
		buf.WriteString(`"rootfs":`)
		fflib.WriteJsonString(buf, string(j.Rootfs))
		buf.WriteByte(',')
	}
	if j.ImageVolumes {
		buf.WriteString(`"imageVolumes":true`)
	} else {
		buf.WriteString(`"imageVolumes":false`)
	}
	buf.WriteByte(',')
	if len(j.ShmDir) != 0 {
		buf.WriteString(`"ShmDir":`)
		fflib.WriteJsonString(buf, string(j.ShmDir))
		buf.WriteByte(',')
	}
	buf.WriteString(`"shmSize":`)
	fflib.FormatBits2(buf, uint64(j.ShmSize), 10, j.ShmSize < 0)
	buf.WriteString(`,"staticDir":`)
	fflib.WriteJsonString(buf, string(j.StaticDir))
	buf.WriteByte(',')
	if len(j.Mounts) != 0 {
		buf.WriteString(`"mounts":`)
		if j.Mounts != nil {
			buf.WriteString(`[`)
			for i, v := range j.Mounts {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Privileged {
		buf.WriteString(`"privileged":true`)
	} else {
		buf.WriteString(`"privileged":false`)
	}
	buf.WriteByte(',')
	if len(j.ProcessLabel) != 0 {
		buf.WriteString(`"ProcessLabel":`)
		fflib.WriteJsonString(buf, string(j.ProcessLabel))
		buf.WriteByte(',')
	}
	if len(j.MountLabel) != 0 {
		buf.WriteString(`"MountLabel":`)
		fflib.WriteJsonString(buf, string(j.MountLabel))
		buf.WriteByte(',')
	}
	if len(j.User) != 0 {
		buf.WriteString(`"user":`)
		fflib.WriteJsonString(buf, string(j.User))
		buf.WriteByte(',')
	}
	if len(j.Groups) != 0 {
		buf.WriteString(`"groups":`)
		if j.Groups != nil {
			buf.WriteString(`[`)
			for i, v := range j.Groups {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.IPCNsCtr) != 0 {
		buf.WriteString(`"ipcNsCtr":`)
		fflib.WriteJsonString(buf, string(j.IPCNsCtr))
		buf.WriteByte(',')
	}
	if len(j.MountNsCtr) != 0 {
		buf.WriteString(`"mountNsCtr":`)
		fflib.WriteJsonString(buf, string(j.MountNsCtr))
		buf.WriteByte(',')
	}
	if len(j.NetNsCtr) != 0 {
		buf.WriteString(`"netNsCtr":`)
		fflib.WriteJsonString(buf, string(j.NetNsCtr))
		buf.WriteByte(',')
	}
	if len(j.PIDNsCtr) != 0 {
		buf.WriteString(`"pidNsCtr":`)
		fflib.WriteJsonString(buf, string(j.PIDNsCtr))
		buf.WriteByte(',')
	}
	if len(j.UserNsCtr) != 0 {
		buf.WriteString(`"userNsCtr":`)
		fflib.WriteJsonString(buf, string(j.UserNsCtr))
		buf.WriteByte(',')
	}
	if len(j.UTSNsCtr) != 0 {
		buf.WriteString(`"utsNsCtr":`)
		fflib.WriteJsonString(buf, string(j.UTSNsCtr))
		buf.WriteByte(',')
	}
	if len(j.CgroupNsCtr) != 0 {
		buf.WriteString(`"cgroupNsCtr":`)
		fflib.WriteJsonString(buf, string(j.CgroupNsCtr))
		buf.WriteByte(',')
	}
	buf.WriteString(`"Dependencies":`)
	if j.Dependencies != nil {
		buf.WriteString(`[`)
		for i, v := range j.Dependencies {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.CreateNetNS {
		buf.WriteString(`,"createNetNS":true`)
	} else {
		buf.WriteString(`,"createNetNS":false`)
	}
	buf.WriteByte(',')
	if len(j.PortMappings) != 0 {
		buf.WriteString(`"portMappings":`)
		if j.PortMappings != nil {
			buf.WriteString(`[`)
			for i, v := range j.PortMappings {
				if i != 0 {
					buf.WriteString(`,`)
				}
				/* Struct fall back. type=ocicni.PortMapping kind=struct */
				err = buf.Encode(&v)
				if err != nil {
					return err
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.DNSServer) != 0 {
		buf.WriteString(`"dnsServer":`)
		if j.DNSServer != nil {
			buf.WriteString(`[`)
			for i, v := range j.DNSServer {
				if i != 0 {
					buf.WriteString(`,`)
				}
				if v != nil {
					buf.WriteString(`"`)
					{
						enc := base64.NewEncoder(base64.StdEncoding, buf)
						enc.Write(reflect.Indirect(reflect.ValueOf(v)).Bytes())
						enc.Close()
					}
					buf.WriteString(`"`)
				} else {
					buf.WriteString(`null`)
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.DNSSearch) != 0 {
		buf.WriteString(`"dnsSearch":`)
		if j.DNSSearch != nil {
			buf.WriteString(`[`)
			for i, v := range j.DNSSearch {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.DNSOption) != 0 {
		buf.WriteString(`"dnsOption":`)
		if j.DNSOption != nil {
			buf.WriteString(`[`)
			for i, v := range j.DNSOption {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.HostAdd) != 0 {
		buf.WriteString(`"hostsAdd":`)
		if j.HostAdd != nil {
			buf.WriteString(`[`)
			for i, v := range j.HostAdd {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Networks) != 0 {
		buf.WriteString(`"networks":`)
		if j.Networks != nil {
			buf.WriteString(`[`)
			for i, v := range j.Networks {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.UserVolumes) != 0 {
		buf.WriteString(`"userVolumes":`)
		if j.UserVolumes != nil {
			buf.WriteString(`[`)
			for i, v := range j.UserVolumes {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Entrypoint) != 0 {
		buf.WriteString(`"entrypoint":`)
		if j.Entrypoint != nil {
			buf.WriteString(`[`)
			for i, v := range j.Entrypoint {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Command) != 0 {
		buf.WriteString(`"command":`)
		if j.Command != nil {
			buf.WriteString(`[`)
			for i, v := range j.Command {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Stdin != false {
		if j.Stdin {
			buf.WriteString(`"stdin":true`)
		} else {
			buf.WriteString(`"stdin":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.Labels) != 0 {
		if j.Labels == nil {
			buf.WriteString(`"labels":null`)
		} else {
			buf.WriteString(`"labels":{ `)
			for key, value := range j.Labels {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	if j.StopSignal != 0 {
		buf.WriteString(`"stopSignal":`)
		fflib.FormatBits2(buf, uint64(j.StopSignal), 10, false)
		buf.WriteByte(',')
	}
	if j.StopTimeout != 0 {
		buf.WriteString(`"stopTimeout":`)
		fflib.FormatBits2(buf, uint64(j.StopTimeout), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"createdTime":`)

	{

		obj, err = j.CreatedTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"cgroupParent":`)
	fflib.WriteJsonString(buf, string(j.CgroupParent))
	buf.WriteString(`,"logPath":`)
	fflib.WriteJsonString(buf, string(j.LogPath))
	buf.WriteByte(',')
	if len(j.ConmonPidFile) != 0 {
		buf.WriteString(`"conmonPidFile":`)
		fflib.WriteJsonString(buf, string(j.ConmonPidFile))
		buf.WriteByte(',')
	}
	if j.PostConfigureNetNS {
		buf.WriteString(`"postConfigureNetNS":true`)
	} else {
		buf.WriteString(`"postConfigureNetNS":false`)
	}
	buf.WriteByte(',')
	if len(j.ExitCommand) != 0 {
		buf.WriteString(`"exitCommand":`)
		if j.ExitCommand != nil {
			buf.WriteString(`[`)
			for i, v := range j.ExitCommand {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"LocalVolumes":`)
	if j.LocalVolumes != nil {
		buf.WriteString(`[`)
		for i, v := range j.LocalVolumes {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtContainerConfigbase = iota
	ffjtContainerConfignosuchkey

	ffjtContainerConfigSpec

	ffjtContainerConfigID

	ffjtContainerConfigName

	ffjtContainerConfigPod

	ffjtContainerConfigNamespace

	ffjtContainerConfigIDMappings

	ffjtContainerConfigRootfsImageID

	ffjtContainerConfigRootfsImageName

	ffjtContainerConfigRootfs

	ffjtContainerConfigImageVolumes

	ffjtContainerConfigShmDir

	ffjtContainerConfigShmSize

	ffjtContainerConfigStaticDir

	ffjtContainerConfigMounts

	ffjtContainerConfigPrivileged

	ffjtContainerConfigProcessLabel

	ffjtContainerConfigMountLabel

	ffjtContainerConfigUser

	ffjtContainerConfigGroups

	ffjtContainerConfigIPCNsCtr

	ffjtContainerConfigMountNsCtr

	ffjtContainerConfigNetNsCtr

	ffjtContainerConfigPIDNsCtr

	ffjtContainerConfigUserNsCtr

	ffjtContainerConfigUTSNsCtr

	ffjtContainerConfigCgroupNsCtr

	ffjtContainerConfigDependencies

	ffjtContainerConfigCreateNetNS

	ffjtContainerConfigPortMappings

	ffjtContainerConfigDNSServer

	ffjtContainerConfigDNSSearch

	ffjtContainerConfigDNSOption

	ffjtContainerConfigHostAdd

	ffjtContainerConfigNetworks

	ffjtContainerConfigUserVolumes

	ffjtContainerConfigEntrypoint

	ffjtContainerConfigCommand

	ffjtContainerConfigStdin

	ffjtContainerConfigLabels

	ffjtContainerConfigStopSignal

	ffjtContainerConfigStopTimeout

	ffjtContainerConfigCreatedTime

	ffjtContainerConfigCgroupParent

	ffjtContainerConfigLogPath

	ffjtContainerConfigConmonPidFile

	ffjtContainerConfigPostConfigureNetNS

	ffjtContainerConfigExitCommand

	ffjtContainerConfigLocalVolumes
)

var ffjKeyContainerConfigSpec = []byte("spec")

var ffjKeyContainerConfigID = []byte("id")

var ffjKeyContainerConfigName = []byte("name")

var ffjKeyContainerConfigPod = []byte("pod")

var ffjKeyContainerConfigNamespace = []byte("namespace")

var ffjKeyContainerConfigIDMappings = []byte("idMappingsOptions")

var ffjKeyContainerConfigRootfsImageID = []byte("rootfsImageID")

var ffjKeyContainerConfigRootfsImageName = []byte("rootfsImageName")

var ffjKeyContainerConfigRootfs = []byte("rootfs")

var ffjKeyContainerConfigImageVolumes = []byte("imageVolumes")

var ffjKeyContainerConfigShmDir = []byte("ShmDir")

var ffjKeyContainerConfigShmSize = []byte("shmSize")

var ffjKeyContainerConfigStaticDir = []byte("staticDir")

var ffjKeyContainerConfigMounts = []byte("mounts")

var ffjKeyContainerConfigPrivileged = []byte("privileged")

var ffjKeyContainerConfigProcessLabel = []byte("ProcessLabel")

var ffjKeyContainerConfigMountLabel = []byte("MountLabel")

var ffjKeyContainerConfigUser = []byte("user")

var ffjKeyContainerConfigGroups = []byte("groups")

var ffjKeyContainerConfigIPCNsCtr = []byte("ipcNsCtr")

var ffjKeyContainerConfigMountNsCtr = []byte("mountNsCtr")

var ffjKeyContainerConfigNetNsCtr = []byte("netNsCtr")

var ffjKeyContainerConfigPIDNsCtr = []byte("pidNsCtr")

var ffjKeyContainerConfigUserNsCtr = []byte("userNsCtr")

var ffjKeyContainerConfigUTSNsCtr = []byte("utsNsCtr")

var ffjKeyContainerConfigCgroupNsCtr = []byte("cgroupNsCtr")

var ffjKeyContainerConfigDependencies = []byte("Dependencies")

var ffjKeyContainerConfigCreateNetNS = []byte("createNetNS")

var ffjKeyContainerConfigPortMappings = []byte("portMappings")

var ffjKeyContainerConfigDNSServer = []byte("dnsServer")

var ffjKeyContainerConfigDNSSearch = []byte("dnsSearch")

var ffjKeyContainerConfigDNSOption = []byte("dnsOption")

var ffjKeyContainerConfigHostAdd = []byte("hostsAdd")

var ffjKeyContainerConfigNetworks = []byte("networks")

var ffjKeyContainerConfigUserVolumes = []byte("userVolumes")

var ffjKeyContainerConfigEntrypoint = []byte("entrypoint")

var ffjKeyContainerConfigCommand = []byte("command")

var ffjKeyContainerConfigStdin = []byte("stdin")

var ffjKeyContainerConfigLabels = []byte("labels")

var ffjKeyContainerConfigStopSignal = []byte("stopSignal")

var ffjKeyContainerConfigStopTimeout = []byte("stopTimeout")

var ffjKeyContainerConfigCreatedTime = []byte("createdTime")

var ffjKeyContainerConfigCgroupParent = []byte("cgroupParent")

var ffjKeyContainerConfigLogPath = []byte("logPath")

var ffjKeyContainerConfigConmonPidFile = []byte("conmonPidFile")

var ffjKeyContainerConfigPostConfigureNetNS = []byte("postConfigureNetNS")

var ffjKeyContainerConfigExitCommand = []byte("exitCommand")

var ffjKeyContainerConfigLocalVolumes = []byte("LocalVolumes")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ContainerConfig) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ContainerConfig) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtContainerConfigbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtContainerConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'D':

					if bytes.Equal(ffjKeyContainerConfigDependencies, kn) {
						currentKey = ffjtContainerConfigDependencies
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffjKeyContainerConfigLocalVolumes, kn) {
						currentKey = ffjtContainerConfigLocalVolumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffjKeyContainerConfigMountLabel, kn) {
						currentKey = ffjtContainerConfigMountLabel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyContainerConfigProcessLabel, kn) {
						currentKey = ffjtContainerConfigProcessLabel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyContainerConfigShmDir, kn) {
						currentKey = ffjtContainerConfigShmDir
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyContainerConfigCgroupNsCtr, kn) {
						currentKey = ffjtContainerConfigCgroupNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigCreateNetNS, kn) {
						currentKey = ffjtContainerConfigCreateNetNS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigCommand, kn) {
						currentKey = ffjtContainerConfigCommand
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigCreatedTime, kn) {
						currentKey = ffjtContainerConfigCreatedTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigCgroupParent, kn) {
						currentKey = ffjtContainerConfigCgroupParent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigConmonPidFile, kn) {
						currentKey = ffjtContainerConfigConmonPidFile
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyContainerConfigDNSServer, kn) {
						currentKey = ffjtContainerConfigDNSServer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigDNSSearch, kn) {
						currentKey = ffjtContainerConfigDNSSearch
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigDNSOption, kn) {
						currentKey = ffjtContainerConfigDNSOption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyContainerConfigEntrypoint, kn) {
						currentKey = ffjtContainerConfigEntrypoint
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigExitCommand, kn) {
						currentKey = ffjtContainerConfigExitCommand
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyContainerConfigGroups, kn) {
						currentKey = ffjtContainerConfigGroups
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyContainerConfigHostAdd, kn) {
						currentKey = ffjtContainerConfigHostAdd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyContainerConfigID, kn) {
						currentKey = ffjtContainerConfigID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigIDMappings, kn) {
						currentKey = ffjtContainerConfigIDMappings
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigImageVolumes, kn) {
						currentKey = ffjtContainerConfigImageVolumes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigIPCNsCtr, kn) {
						currentKey = ffjtContainerConfigIPCNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyContainerConfigLabels, kn) {
						currentKey = ffjtContainerConfigLabels
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigLogPath, kn) {
						currentKey = ffjtContainerConfigLogPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyContainerConfigMounts, kn) {
						currentKey = ffjtContainerConfigMounts
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigMountNsCtr, kn) {
						currentKey = ffjtContainerConfigMountNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyContainerConfigName, kn) {
						currentKey = ffjtContainerConfigName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigNamespace, kn) {
						currentKey = ffjtContainerConfigNamespace
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigNetNsCtr, kn) {
						currentKey = ffjtContainerConfigNetNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigNetworks, kn) {
						currentKey = ffjtContainerConfigNetworks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyContainerConfigPod, kn) {
						currentKey = ffjtContainerConfigPod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigPrivileged, kn) {
						currentKey = ffjtContainerConfigPrivileged
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigPIDNsCtr, kn) {
						currentKey = ffjtContainerConfigPIDNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigPortMappings, kn) {
						currentKey = ffjtContainerConfigPortMappings
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigPostConfigureNetNS, kn) {
						currentKey = ffjtContainerConfigPostConfigureNetNS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyContainerConfigRootfsImageID, kn) {
						currentKey = ffjtContainerConfigRootfsImageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigRootfsImageName, kn) {
						currentKey = ffjtContainerConfigRootfsImageName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigRootfs, kn) {
						currentKey = ffjtContainerConfigRootfs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyContainerConfigSpec, kn) {
						currentKey = ffjtContainerConfigSpec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigShmSize, kn) {
						currentKey = ffjtContainerConfigShmSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigStaticDir, kn) {
						currentKey = ffjtContainerConfigStaticDir
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigStdin, kn) {
						currentKey = ffjtContainerConfigStdin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigStopSignal, kn) {
						currentKey = ffjtContainerConfigStopSignal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigStopTimeout, kn) {
						currentKey = ffjtContainerConfigStopTimeout
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyContainerConfigUser, kn) {
						currentKey = ffjtContainerConfigUser
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigUserNsCtr, kn) {
						currentKey = ffjtContainerConfigUserNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigUTSNsCtr, kn) {
						currentKey = ffjtContainerConfigUTSNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigUserVolumes, kn) {
						currentKey = ffjtContainerConfigUserVolumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigLocalVolumes, kn) {
					currentKey = ffjtContainerConfigLocalVolumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigExitCommand, kn) {
					currentKey = ffjtContainerConfigExitCommand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigPostConfigureNetNS, kn) {
					currentKey = ffjtContainerConfigPostConfigureNetNS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigConmonPidFile, kn) {
					currentKey = ffjtContainerConfigConmonPidFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigLogPath, kn) {
					currentKey = ffjtContainerConfigLogPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigCgroupParent, kn) {
					currentKey = ffjtContainerConfigCgroupParent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigCreatedTime, kn) {
					currentKey = ffjtContainerConfigCreatedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigStopTimeout, kn) {
					currentKey = ffjtContainerConfigStopTimeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigStopSignal, kn) {
					currentKey = ffjtContainerConfigStopSignal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigLabels, kn) {
					currentKey = ffjtContainerConfigLabels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigStdin, kn) {
					currentKey = ffjtContainerConfigStdin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigCommand, kn) {
					currentKey = ffjtContainerConfigCommand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigEntrypoint, kn) {
					currentKey = ffjtContainerConfigEntrypoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigUserVolumes, kn) {
					currentKey = ffjtContainerConfigUserVolumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigNetworks, kn) {
					currentKey = ffjtContainerConfigNetworks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigHostAdd, kn) {
					currentKey = ffjtContainerConfigHostAdd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigDNSOption, kn) {
					currentKey = ffjtContainerConfigDNSOption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigDNSSearch, kn) {
					currentKey = ffjtContainerConfigDNSSearch
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigDNSServer, kn) {
					currentKey = ffjtContainerConfigDNSServer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigPortMappings, kn) {
					currentKey = ffjtContainerConfigPortMappings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigCreateNetNS, kn) {
					currentKey = ffjtContainerConfigCreateNetNS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigDependencies, kn) {
					currentKey = ffjtContainerConfigDependencies
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigCgroupNsCtr, kn) {
					currentKey = ffjtContainerConfigCgroupNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigUTSNsCtr, kn) {
					currentKey = ffjtContainerConfigUTSNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigUserNsCtr, kn) {
					currentKey = ffjtContainerConfigUserNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigPIDNsCtr, kn) {
					currentKey = ffjtContainerConfigPIDNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigNetNsCtr, kn) {
					currentKey = ffjtContainerConfigNetNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigMountNsCtr, kn) {
					currentKey = ffjtContainerConfigMountNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigIPCNsCtr, kn) {
					currentKey = ffjtContainerConfigIPCNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigGroups, kn) {
					currentKey = ffjtContainerConfigGroups
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigUser, kn) {
					currentKey = ffjtContainerConfigUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigMountLabel, kn) {
					currentKey = ffjtContainerConfigMountLabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigProcessLabel, kn) {
					currentKey = ffjtContainerConfigProcessLabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigPrivileged, kn) {
					currentKey = ffjtContainerConfigPrivileged
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigMounts, kn) {
					currentKey = ffjtContainerConfigMounts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigStaticDir, kn) {
					currentKey = ffjtContainerConfigStaticDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigShmSize, kn) {
					currentKey = ffjtContainerConfigShmSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigShmDir, kn) {
					currentKey = ffjtContainerConfigShmDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigImageVolumes, kn) {
					currentKey = ffjtContainerConfigImageVolumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigRootfs, kn) {
					currentKey = ffjtContainerConfigRootfs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigRootfsImageName, kn) {
					currentKey = ffjtContainerConfigRootfsImageName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigRootfsImageID, kn) {
					currentKey = ffjtContainerConfigRootfsImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigIDMappings, kn) {
					currentKey = ffjtContainerConfigIDMappings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigNamespace, kn) {
					currentKey = ffjtContainerConfigNamespace
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigPod, kn) {
					currentKey = ffjtContainerConfigPod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigName, kn) {
					currentKey = ffjtContainerConfigName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigID, kn) {
					currentKey = ffjtContainerConfigID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigSpec, kn) {
					currentKey = ffjtContainerConfigSpec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtContainerConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtContainerConfigSpec:
					goto handle_Spec

				case ffjtContainerConfigID:
					goto handle_ID

				case ffjtContainerConfigName:
					goto handle_Name

				case ffjtContainerConfigPod:
					goto handle_Pod

				case ffjtContainerConfigNamespace:
					goto handle_Namespace

				case ffjtContainerConfigIDMappings:
					goto handle_IDMappings

				case ffjtContainerConfigRootfsImageID:
					goto handle_RootfsImageID

				case ffjtContainerConfigRootfsImageName:
					goto handle_RootfsImageName

				case ffjtContainerConfigRootfs:
					goto handle_Rootfs

				case ffjtContainerConfigImageVolumes:
					goto handle_ImageVolumes

				case ffjtContainerConfigShmDir:
					goto handle_ShmDir

				case ffjtContainerConfigShmSize:
					goto handle_ShmSize

				case ffjtContainerConfigStaticDir:
					goto handle_StaticDir

				case ffjtContainerConfigMounts:
					goto handle_Mounts

				case ffjtContainerConfigPrivileged:
					goto handle_Privileged

				case ffjtContainerConfigProcessLabel:
					goto handle_ProcessLabel

				case ffjtContainerConfigMountLabel:
					goto handle_MountLabel

				case ffjtContainerConfigUser:
					goto handle_User

				case ffjtContainerConfigGroups:
					goto handle_Groups

				case ffjtContainerConfigIPCNsCtr:
					goto handle_IPCNsCtr

				case ffjtContainerConfigMountNsCtr:
					goto handle_MountNsCtr

				case ffjtContainerConfigNetNsCtr:
					goto handle_NetNsCtr

				case ffjtContainerConfigPIDNsCtr:
					goto handle_PIDNsCtr

				case ffjtContainerConfigUserNsCtr:
					goto handle_UserNsCtr

				case ffjtContainerConfigUTSNsCtr:
					goto handle_UTSNsCtr

				case ffjtContainerConfigCgroupNsCtr:
					goto handle_CgroupNsCtr

				case ffjtContainerConfigDependencies:
					goto handle_Dependencies

				case ffjtContainerConfigCreateNetNS:
					goto handle_CreateNetNS

				case ffjtContainerConfigPortMappings:
					goto handle_PortMappings

				case ffjtContainerConfigDNSServer:
					goto handle_DNSServer

				case ffjtContainerConfigDNSSearch:
					goto handle_DNSSearch

				case ffjtContainerConfigDNSOption:
					goto handle_DNSOption

				case ffjtContainerConfigHostAdd:
					goto handle_HostAdd

				case ffjtContainerConfigNetworks:
					goto handle_Networks

				case ffjtContainerConfigUserVolumes:
					goto handle_UserVolumes

				case ffjtContainerConfigEntrypoint:
					goto handle_Entrypoint

				case ffjtContainerConfigCommand:
					goto handle_Command

				case ffjtContainerConfigStdin:
					goto handle_Stdin

				case ffjtContainerConfigLabels:
					goto handle_Labels

				case ffjtContainerConfigStopSignal:
					goto handle_StopSignal

				case ffjtContainerConfigStopTimeout:
					goto handle_StopTimeout

				case ffjtContainerConfigCreatedTime:
					goto handle_CreatedTime

				case ffjtContainerConfigCgroupParent:
					goto handle_CgroupParent

				case ffjtContainerConfigLogPath:
					goto handle_LogPath

				case ffjtContainerConfigConmonPidFile:
					goto handle_ConmonPidFile

				case ffjtContainerConfigPostConfigureNetNS:
					goto handle_PostConfigureNetNS

				case ffjtContainerConfigExitCommand:
					goto handle_ExitCommand

				case ffjtContainerConfigLocalVolumes:
					goto handle_LocalVolumes

				case ffjtContainerConfignosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Spec:

	/* handler: j.Spec type=specs.Spec kind=struct quoted=false*/

	{
		/* Falling back. type=specs.Spec kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Spec)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pod:

	/* handler: j.Pod type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Pod = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Namespace:

	/* handler: j.Namespace type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Namespace = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IDMappings:

	/* handler: j.IDMappings type=storage.IDMappingOptions kind=struct quoted=false*/

	{
		/* Falling back. type=storage.IDMappingOptions kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.IDMappings)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RootfsImageID:

	/* handler: j.RootfsImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RootfsImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RootfsImageName:

	/* handler: j.RootfsImageName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RootfsImageName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rootfs:

	/* handler: j.Rootfs type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Rootfs = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageVolumes:

	/* handler: j.ImageVolumes type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ImageVolumes = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ImageVolumes = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShmDir:

	/* handler: j.ShmDir type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ShmDir = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShmSize:

	/* handler: j.ShmSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ShmSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StaticDir:

	/* handler: j.StaticDir type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StaticDir = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mounts:

	/* handler: j.Mounts type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Mounts = nil
		} else {

			j.Mounts = []string{}

			wantVal := true

			for {

				var tmpJMounts string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMounts type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJMounts = string(string(outBuf))

					}
				}

				j.Mounts = append(j.Mounts, tmpJMounts)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Privileged:

	/* handler: j.Privileged type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Privileged = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Privileged = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProcessLabel:

	/* handler: j.ProcessLabel type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProcessLabel = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MountLabel:

	/* handler: j.MountLabel type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MountLabel = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.User = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Groups:

	/* handler: j.Groups type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Groups = nil
		} else {

			j.Groups = []string{}

			wantVal := true

			for {

				var tmpJGroups string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJGroups type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJGroups = string(string(outBuf))

					}
				}

				j.Groups = append(j.Groups, tmpJGroups)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IPCNsCtr:

	/* handler: j.IPCNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.IPCNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MountNsCtr:

	/* handler: j.MountNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MountNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetNsCtr:

	/* handler: j.NetNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NetNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PIDNsCtr:

	/* handler: j.PIDNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PIDNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserNsCtr:

	/* handler: j.UserNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UserNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UTSNsCtr:

	/* handler: j.UTSNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UTSNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CgroupNsCtr:

	/* handler: j.CgroupNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CgroupNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dependencies:

	/* handler: j.Dependencies type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Dependencies = nil
		} else {

			j.Dependencies = []string{}

			wantVal := true

			for {

				var tmpJDependencies string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDependencies type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJDependencies = string(string(outBuf))

					}
				}

				j.Dependencies = append(j.Dependencies, tmpJDependencies)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreateNetNS:

	/* handler: j.CreateNetNS type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CreateNetNS = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CreateNetNS = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PortMappings:

	/* handler: j.PortMappings type=[]ocicni.PortMapping kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.PortMappings = nil
		} else {

			j.PortMappings = []ocicni.PortMapping{}

			wantVal := true

			for {

				var tmpJPortMappings ocicni.PortMapping

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPortMappings type=ocicni.PortMapping kind=struct quoted=false*/

				{
					/* Falling back. type=ocicni.PortMapping kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJPortMappings)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.PortMappings = append(j.PortMappings, tmpJPortMappings)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DNSServer:

	/* handler: j.DNSServer type=[]net.IP kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.DNSServer = nil
		} else {

			j.DNSServer = []net.IP{}

			wantVal := true

			for {

				var tmpJDNSServer net.IP

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDNSServer type=net.IP kind=slice quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for IP", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmpJDNSServer = nil
					} else {
						b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
						n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
						if err != nil {
							return fs.WrapErr(err)
						}

						v := reflect.ValueOf(&tmpJDNSServer).Elem()
						v.SetBytes(b[0:n])

					}
				}

				j.DNSServer = append(j.DNSServer, tmpJDNSServer)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DNSSearch:

	/* handler: j.DNSSearch type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.DNSSearch = nil
		} else {

			j.DNSSearch = []string{}

			wantVal := true

			for {

				var tmpJDNSSearch string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDNSSearch type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJDNSSearch = string(string(outBuf))

					}
				}

				j.DNSSearch = append(j.DNSSearch, tmpJDNSSearch)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DNSOption:

	/* handler: j.DNSOption type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.DNSOption = nil
		} else {

			j.DNSOption = []string{}

			wantVal := true

			for {

				var tmpJDNSOption string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDNSOption type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJDNSOption = string(string(outBuf))

					}
				}

				j.DNSOption = append(j.DNSOption, tmpJDNSOption)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostAdd:

	/* handler: j.HostAdd type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.HostAdd = nil
		} else {

			j.HostAdd = []string{}

			wantVal := true

			for {

				var tmpJHostAdd string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJHostAdd type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJHostAdd = string(string(outBuf))

					}
				}

				j.HostAdd = append(j.HostAdd, tmpJHostAdd)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Networks:

	/* handler: j.Networks type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Networks = nil
		} else {

			j.Networks = []string{}

			wantVal := true

			for {

				var tmpJNetworks string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNetworks type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJNetworks = string(string(outBuf))

					}
				}

				j.Networks = append(j.Networks, tmpJNetworks)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserVolumes:

	/* handler: j.UserVolumes type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.UserVolumes = nil
		} else {

			j.UserVolumes = []string{}

			wantVal := true

			for {

				var tmpJUserVolumes string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJUserVolumes type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJUserVolumes = string(string(outBuf))

					}
				}

				j.UserVolumes = append(j.UserVolumes, tmpJUserVolumes)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entrypoint:

	/* handler: j.Entrypoint type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Entrypoint = nil
		} else {

			j.Entrypoint = []string{}

			wantVal := true

			for {

				var tmpJEntrypoint string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEntrypoint type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJEntrypoint = string(string(outBuf))

					}
				}

				j.Entrypoint = append(j.Entrypoint, tmpJEntrypoint)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: j.Command type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Command = nil
		} else {

			j.Command = []string{}

			wantVal := true

			for {

				var tmpJCommand string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCommand type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJCommand = string(string(outBuf))

					}
				}

				j.Command = append(j.Command, tmpJCommand)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Stdin:

	/* handler: j.Stdin type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Stdin = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Stdin = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: j.Labels type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Labels = nil
		} else {

			j.Labels = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJLabels string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJLabels type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJLabels = string(string(outBuf))

					}
				}

				j.Labels[k] = tmpJLabels

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StopSignal:

	/* handler: j.StopSignal type=uint kind=uint quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StopSignal = uint(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StopTimeout:

	/* handler: j.StopTimeout type=uint kind=uint quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StopTimeout = uint(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedTime:

	/* handler: j.CreatedTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CreatedTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CgroupParent:

	/* handler: j.CgroupParent type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CgroupParent = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LogPath:

	/* handler: j.LogPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LogPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConmonPidFile:

	/* handler: j.ConmonPidFile type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ConmonPidFile = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PostConfigureNetNS:

	/* handler: j.PostConfigureNetNS type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.PostConfigureNetNS = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.PostConfigureNetNS = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExitCommand:

	/* handler: j.ExitCommand type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ExitCommand = nil
		} else {

			j.ExitCommand = []string{}

			wantVal := true

			for {

				var tmpJExitCommand string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJExitCommand type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJExitCommand = string(string(outBuf))

					}
				}

				j.ExitCommand = append(j.ExitCommand, tmpJExitCommand)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LocalVolumes:

	/* handler: j.LocalVolumes type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.LocalVolumes = nil
		} else {

			j.LocalVolumes = []string{}

			wantVal := true

			for {

				var tmpJLocalVolumes string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJLocalVolumes type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJLocalVolumes = string(string(outBuf))

					}
				}

				j.LocalVolumes = append(j.LocalVolumes, tmpJLocalVolumes)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ExecSession) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ExecSession) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"command":`)
	if j.Command != nil {
		buf.WriteString(`[`)
		for i, v := range j.Command {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"pid":`)
	fflib.FormatBits2(buf, uint64(j.PID), 10, j.PID < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtExecSessionbase = iota
	ffjtExecSessionnosuchkey

	ffjtExecSessionID

	ffjtExecSessionCommand

	ffjtExecSessionPID
)

var ffjKeyExecSessionID = []byte("id")

var ffjKeyExecSessionCommand = []byte("command")

var ffjKeyExecSessionPID = []byte("pid")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ExecSession) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ExecSession) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtExecSessionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtExecSessionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyExecSessionCommand, kn) {
						currentKey = ffjtExecSessionCommand
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyExecSessionID, kn) {
						currentKey = ffjtExecSessionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyExecSessionPID, kn) {
						currentKey = ffjtExecSessionPID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyExecSessionPID, kn) {
					currentKey = ffjtExecSessionPID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyExecSessionCommand, kn) {
					currentKey = ffjtExecSessionCommand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyExecSessionID, kn) {
					currentKey = ffjtExecSessionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtExecSessionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtExecSessionID:
					goto handle_ID

				case ffjtExecSessionCommand:
					goto handle_Command

				case ffjtExecSessionPID:
					goto handle_PID

				case ffjtExecSessionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: j.Command type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Command = nil
		} else {

			j.Command = []string{}

			wantVal := true

			for {

				var tmpJCommand string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCommand type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJCommand = string(string(outBuf))

					}
				}

				j.Command = append(j.Command, tmpJCommand)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PID:

	/* handler: j.PID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *containerState) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *containerState) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "state":`)
	fflib.FormatBits2(buf, uint64(j.State), 10, j.State < 0)
	buf.WriteByte(',')
	if len(j.ConfigPath) != 0 {
		buf.WriteString(`"configPath":`)
		fflib.WriteJsonString(buf, string(j.ConfigPath))
		buf.WriteByte(',')
	}
	if len(j.RunDir) != 0 {
		buf.WriteString(`"runDir":`)
		fflib.WriteJsonString(buf, string(j.RunDir))
		buf.WriteByte(',')
	}
	if len(j.DestinationRunDir) != 0 {
		buf.WriteString(`"destinationRunDir":`)
		fflib.WriteJsonString(buf, string(j.DestinationRunDir))
		buf.WriteByte(',')
	}
	if j.Mounted != false {
		if j.Mounted {
			buf.WriteString(`"mounted":true`)
		} else {
			buf.WriteString(`"mounted":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.Mountpoint) != 0 {
		buf.WriteString(`"mountPoint":`)
		fflib.WriteJsonString(buf, string(j.Mountpoint))
		buf.WriteByte(',')
	}
	if len(j.RealMountpoint) != 0 {
		buf.WriteString(`"realMountPoint":`)
		fflib.WriteJsonString(buf, string(j.RealMountpoint))
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"startedTime":`)

		{

			obj, err = j.StartedTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"finishedTime":`)

		{

			obj, err = j.FinishedTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.ExitCode != 0 {
		buf.WriteString(`"exitCode":`)
		fflib.FormatBits2(buf, uint64(j.ExitCode), 10, j.ExitCode < 0)
		buf.WriteByte(',')
	}
	if j.Exited != false {
		if j.Exited {
			buf.WriteString(`"exited":true`)
		} else {
			buf.WriteString(`"exited":false`)
		}
		buf.WriteByte(',')
	}
	if j.OOMKilled != false {
		if j.OOMKilled {
			buf.WriteString(`"oomKilled":true`)
		} else {
			buf.WriteString(`"oomKilled":false`)
		}
		buf.WriteByte(',')
	}
	if j.PID != 0 {
		buf.WriteString(`"pid":`)
		fflib.FormatBits2(buf, uint64(j.PID), 10, j.PID < 0)
		buf.WriteByte(',')
	}
	if len(j.ExecSessions) != 0 {
		buf.WriteString(`"execSessions":`)
		/* Falling back. type=map[string]*libpod.ExecSession kind=map */
		err = buf.Encode(j.ExecSessions)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.NetworkStatus) != 0 {
		buf.WriteString(`"networkResults":`)
		if j.NetworkStatus != nil {
			buf.WriteString(`[`)
			for i, v := range j.NetworkStatus {
				if i != 0 {
					buf.WriteString(`,`)
				}
				if v != nil {
					/* Struct fall back. type=current.Result kind=struct */
					err = buf.Encode(&v)
					if err != nil {
						return err
					}
				} else {
					buf.WriteString(`null`)
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.BindMounts) != 0 {
		if j.BindMounts == nil {
			buf.WriteString(`"bindMounts":null`)
		} else {
			buf.WriteString(`"bindMounts":{ `)
			for key, value := range j.BindMounts {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	if len(j.UserNSRoot) != 0 {
		buf.WriteString(`"userNSRoot":`)
		fflib.WriteJsonString(buf, string(j.UserNSRoot))
		buf.WriteByte(',')
	}
	if len(j.ExtensionStageHooks) != 0 {
		buf.WriteString(`"extensionStageHooks":`)
		/* Falling back. type=map[string][]specs.Hook kind=map */
		err = buf.Encode(j.ExtensionStageHooks)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtcontainerStatebase = iota
	ffjtcontainerStatenosuchkey

	ffjtcontainerStateState

	ffjtcontainerStateConfigPath

	ffjtcontainerStateRunDir

	ffjtcontainerStateDestinationRunDir

	ffjtcontainerStateMounted

	ffjtcontainerStateMountpoint

	ffjtcontainerStateRealMountpoint

	ffjtcontainerStateStartedTime

	ffjtcontainerStateFinishedTime

	ffjtcontainerStateExitCode

	ffjtcontainerStateExited

	ffjtcontainerStateOOMKilled

	ffjtcontainerStatePID

	ffjtcontainerStateExecSessions

	ffjtcontainerStateNetworkStatus

	ffjtcontainerStateBindMounts

	ffjtcontainerStateUserNSRoot

	ffjtcontainerStateExtensionStageHooks
)

var ffjKeycontainerStateState = []byte("state")

var ffjKeycontainerStateConfigPath = []byte("configPath")

var ffjKeycontainerStateRunDir = []byte("runDir")

var ffjKeycontainerStateDestinationRunDir = []byte("destinationRunDir")

var ffjKeycontainerStateMounted = []byte("mounted")

var ffjKeycontainerStateMountpoint = []byte("mountPoint")

var ffjKeycontainerStateRealMountpoint = []byte("realMountPoint")

var ffjKeycontainerStateStartedTime = []byte("startedTime")

var ffjKeycontainerStateFinishedTime = []byte("finishedTime")

var ffjKeycontainerStateExitCode = []byte("exitCode")

var ffjKeycontainerStateExited = []byte("exited")

var ffjKeycontainerStateOOMKilled = []byte("oomKilled")

var ffjKeycontainerStatePID = []byte("pid")

var ffjKeycontainerStateExecSessions = []byte("execSessions")

var ffjKeycontainerStateNetworkStatus = []byte("networkResults")

var ffjKeycontainerStateBindMounts = []byte("bindMounts")

var ffjKeycontainerStateUserNSRoot = []byte("userNSRoot")

var ffjKeycontainerStateExtensionStageHooks = []byte("extensionStageHooks")

// UnmarshalJSON umarshall json - template of ffjson
func (j *containerState) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *containerState) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtcontainerStatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtcontainerStatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeycontainerStateBindMounts, kn) {
						currentKey = ffjtcontainerStateBindMounts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeycontainerStateConfigPath, kn) {
						currentKey = ffjtcontainerStateConfigPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeycontainerStateDestinationRunDir, kn) {
						currentKey = ffjtcontainerStateDestinationRunDir
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeycontainerStateExitCode, kn) {
						currentKey = ffjtcontainerStateExitCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateExited, kn) {
						currentKey = ffjtcontainerStateExited
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateExecSessions, kn) {
						currentKey = ffjtcontainerStateExecSessions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateExtensionStageHooks, kn) {
						currentKey = ffjtcontainerStateExtensionStageHooks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeycontainerStateFinishedTime, kn) {
						currentKey = ffjtcontainerStateFinishedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeycontainerStateMounted, kn) {
						currentKey = ffjtcontainerStateMounted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateMountpoint, kn) {
						currentKey = ffjtcontainerStateMountpoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeycontainerStateNetworkStatus, kn) {
						currentKey = ffjtcontainerStateNetworkStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeycontainerStateOOMKilled, kn) {
						currentKey = ffjtcontainerStateOOMKilled
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeycontainerStatePID, kn) {
						currentKey = ffjtcontainerStatePID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeycontainerStateRunDir, kn) {
						currentKey = ffjtcontainerStateRunDir
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateRealMountpoint, kn) {
						currentKey = ffjtcontainerStateRealMountpoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeycontainerStateState, kn) {
						currentKey = ffjtcontainerStateState
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateStartedTime, kn) {
						currentKey = ffjtcontainerStateStartedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeycontainerStateUserNSRoot, kn) {
						currentKey = ffjtcontainerStateUserNSRoot
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeycontainerStateExtensionStageHooks, kn) {
					currentKey = ffjtcontainerStateExtensionStageHooks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateUserNSRoot, kn) {
					currentKey = ffjtcontainerStateUserNSRoot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateBindMounts, kn) {
					currentKey = ffjtcontainerStateBindMounts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateNetworkStatus, kn) {
					currentKey = ffjtcontainerStateNetworkStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateExecSessions, kn) {
					currentKey = ffjtcontainerStateExecSessions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStatePID, kn) {
					currentKey = ffjtcontainerStatePID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateOOMKilled, kn) {
					currentKey = ffjtcontainerStateOOMKilled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateExited, kn) {
					currentKey = ffjtcontainerStateExited
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateExitCode, kn) {
					currentKey = ffjtcontainerStateExitCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateFinishedTime, kn) {
					currentKey = ffjtcontainerStateFinishedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateStartedTime, kn) {
					currentKey = ffjtcontainerStateStartedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateRealMountpoint, kn) {
					currentKey = ffjtcontainerStateRealMountpoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateMountpoint, kn) {
					currentKey = ffjtcontainerStateMountpoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateMounted, kn) {
					currentKey = ffjtcontainerStateMounted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateDestinationRunDir, kn) {
					currentKey = ffjtcontainerStateDestinationRunDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateRunDir, kn) {
					currentKey = ffjtcontainerStateRunDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateConfigPath, kn) {
					currentKey = ffjtcontainerStateConfigPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateState, kn) {
					currentKey = ffjtcontainerStateState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtcontainerStatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtcontainerStateState:
					goto handle_State

				case ffjtcontainerStateConfigPath:
					goto handle_ConfigPath

				case ffjtcontainerStateRunDir:
					goto handle_RunDir

				case ffjtcontainerStateDestinationRunDir:
					goto handle_DestinationRunDir

				case ffjtcontainerStateMounted:
					goto handle_Mounted

				case ffjtcontainerStateMountpoint:
					goto handle_Mountpoint

				case ffjtcontainerStateRealMountpoint:
					goto handle_RealMountpoint

				case ffjtcontainerStateStartedTime:
					goto handle_StartedTime

				case ffjtcontainerStateFinishedTime:
					goto handle_FinishedTime

				case ffjtcontainerStateExitCode:
					goto handle_ExitCode

				case ffjtcontainerStateExited:
					goto handle_Exited

				case ffjtcontainerStateOOMKilled:
					goto handle_OOMKilled

				case ffjtcontainerStatePID:
					goto handle_PID

				case ffjtcontainerStateExecSessions:
					goto handle_ExecSessions

				case ffjtcontainerStateNetworkStatus:
					goto handle_NetworkStatus

				case ffjtcontainerStateBindMounts:
					goto handle_BindMounts

				case ffjtcontainerStateUserNSRoot:
					goto handle_UserNSRoot

				case ffjtcontainerStateExtensionStageHooks:
					goto handle_ExtensionStageHooks

				case ffjtcontainerStatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_State:

	/* handler: j.State type=libpod.ContainerStatus kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ContainerStatus", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.State = ContainerStatus(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConfigPath:

	/* handler: j.ConfigPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ConfigPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RunDir:

	/* handler: j.RunDir type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RunDir = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DestinationRunDir:

	/* handler: j.DestinationRunDir type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DestinationRunDir = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mounted:

	/* handler: j.Mounted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Mounted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Mounted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mountpoint:

	/* handler: j.Mountpoint type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mountpoint = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RealMountpoint:

	/* handler: j.RealMountpoint type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RealMountpoint = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartedTime:

	/* handler: j.StartedTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.StartedTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FinishedTime:

	/* handler: j.FinishedTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.FinishedTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExitCode:

	/* handler: j.ExitCode type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ExitCode = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Exited:

	/* handler: j.Exited type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Exited = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Exited = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OOMKilled:

	/* handler: j.OOMKilled type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.OOMKilled = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.OOMKilled = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PID:

	/* handler: j.PID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecSessions:

	/* handler: j.ExecSessions type=map[string]*libpod.ExecSession kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ExecSessions = nil
		} else {

			j.ExecSessions = make(map[string]*ExecSession, 0)

			wantVal := true

			for {

				var k string

				var tmpJExecSessions *ExecSession

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJExecSessions type=*libpod.ExecSession kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJExecSessions = nil

					} else {

						if tmpJExecSessions == nil {
							tmpJExecSessions = new(ExecSession)
						}

						err = tmpJExecSessions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ExecSessions[k] = tmpJExecSessions

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetworkStatus:

	/* handler: j.NetworkStatus type=[]*current.Result kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.NetworkStatus = nil
		} else {

			j.NetworkStatus = []*current.Result{}

			wantVal := true

			for {

				var tmpJNetworkStatus *current.Result

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNetworkStatus type=*current.Result kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmpJNetworkStatus = nil
					} else {
						if tmpJNetworkStatus == nil {
							tmpJNetworkStatus = new(current.Result)
						}

						/* handler: tmpJNetworkStatus type=current.Result kind=struct quoted=false*/

						{
							/* Falling back. type=current.Result kind=struct */
							tbuf, err := fs.CaptureField(tok)
							if err != nil {
								return fs.WrapErr(err)
							}

							err = json.Unmarshal(tbuf, &tmpJNetworkStatus)
							if err != nil {
								return fs.WrapErr(err)
							}
						}

					}
				}

				j.NetworkStatus = append(j.NetworkStatus, tmpJNetworkStatus)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BindMounts:

	/* handler: j.BindMounts type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.BindMounts = nil
		} else {

			j.BindMounts = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJBindMounts string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJBindMounts type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJBindMounts = string(string(outBuf))

					}
				}

				j.BindMounts[k] = tmpJBindMounts

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserNSRoot:

	/* handler: j.UserNSRoot type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UserNSRoot = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExtensionStageHooks:

	/* handler: j.ExtensionStageHooks type=map[string][]specs.Hook kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ExtensionStageHooks = nil
		} else {

			j.ExtensionStageHooks = make(map[string][]specs.Hook, 0)

			wantVal := true

			for {

				var k string

				var tmpJExtensionStageHooks []specs.Hook

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJExtensionStageHooks type=[]specs.Hook kind=slice quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmpJExtensionStageHooks = nil
					} else {

						tmpJExtensionStageHooks = []specs.Hook{}

						wantVal := true

						for {

							var tmpTmpJExtensionStageHooks specs.Hook

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_brace {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: tmpTmpJExtensionStageHooks type=specs.Hook kind=struct quoted=false*/

							{
								/* Falling back. type=specs.Hook kind=struct */
								tbuf, err := fs.CaptureField(tok)
								if err != nil {
									return fs.WrapErr(err)
								}

								err = json.Unmarshal(tbuf, &tmpTmpJExtensionStageHooks)
								if err != nil {
									return fs.WrapErr(err)
								}
							}

							tmpJExtensionStageHooks = append(tmpJExtensionStageHooks, tmpTmpJExtensionStageHooks)

							wantVal = false
						}
					}
				}

				j.ExtensionStageHooks[k] = tmpJExtensionStageHooks

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
